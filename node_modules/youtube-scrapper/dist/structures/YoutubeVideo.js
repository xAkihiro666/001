"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YoutubeVideo = void 0;
const axios_1 = __importDefault(require("axios"));
const miniget_1 = __importDefault(require("miniget"));
const m3u8stream_1 = __importDefault(require("m3u8stream"));
const querystring_1 = __importDefault(require("querystring"));
const Util_1 = require("../util/Util");
const stream_1 = require("stream");
const cache_1 = require("../util/cache");
const decipher_1 = require("../util/decipher");
const __1 = require("..");
class YoutubeVideo {
    constructor(json) {
        this.json = json;
    }
    get url() {
        return Util_1.Util.getYTVideoURL() + this.info.id;
    }
    get formats() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const arr = (_a = [...this.moreFormats]) !== null && _a !== void 0 ? _a : [];
        for (const format of [].concat((_c = (_b = this.json.streamingData) === null || _b === void 0 ? void 0 : _b.adaptiveFormats) !== null && _c !== void 0 ? _c : [], (_e = (_d = this.json.streamingData) === null || _d === void 0 ? void 0 : _d.formats) !== null && _e !== void 0 ? _e : [])) {
            let frmt = {
                itag: format.itag,
                mimeType: format.mimeType,
                type: format.mimeType.split(";")[0],
                codec: format.mimeType.split('"')[1].split('"')[0],
                bitrate: format.bitrate,
                width: format.width,
                height: format.height,
                initRange: {
                    start: Number((_f = format.initRange) === null || _f === void 0 ? void 0 : _f.start),
                    end: Number((_g = format.initRange) === null || _g === void 0 ? void 0 : _g.end)
                },
                indexRange: {
                    start: Number((_h = format.indexRange) === null || _h === void 0 ? void 0 : _h.start),
                    end: Number((_j = format.indexRange) === null || _j === void 0 ? void 0 : _j.end)
                },
                lastModifiedTimestamp: Number(format.lastModified),
                contentLength: Number(format.contentLength),
                fps: format.fps,
                quality: format.quality,
                url: format.url,
                qualityLabel: format.qualityLabel,
                projectionType: format.projectionType,
                averageBitrate: format.averageBitrate,
                approxDurationMs: Number(format.approxDurationMs),
                signatureCipher: (_k = format.signatureCipher) !== null && _k !== void 0 ? _k : format.cipher,
                getDecodedCipher: () => decodeURIComponent(format.signatureCipher),
            };
            if (format.url && !frmt.signatureCipher) {
                frmt.url = format.url;
            }
            if (!frmt.url) {
                frmt = Object.assign(frmt, querystring_1.default.parse(frmt.signatureCipher));
            }
            let sig = this.tokens && frmt.s ? YoutubeVideo.decipher(this.tokens, frmt.s) : undefined;
            const url = new URL(decodeURIComponent(frmt.url));
            url.searchParams.set("ratebypass", "yes");
            if (sig) {
                url.searchParams.set((_l = frmt.sp) !== null && _l !== void 0 ? _l : "signature", sig);
            }
            frmt.url = url.toString();
            arr.push(Util_1.Util.addMetadataToFormat(frmt));
        }
        return arr;
    }
    download(format, options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!format)
            throw new Error(`No format was given to download ${this.url}.`);
        if (format.isHLS || format.isDashMPD) {
            return m3u8stream_1.default(format.url, {
                id: String(format.itag),
                parser: format.isDashMPD ? "dash-mpd" : "m3u8",
                highWaterMark: (_a = options.highWaterMark) !== null && _a !== void 0 ? _a : 64 * 1024,
                begin: (_b = options.begin) !== null && _b !== void 0 ? _b : (format.isLive ? Date.now() : 0),
                requestOptions: {
                    maxReconnects: Infinity,
                    maxRetries: 10,
                    backoff: { inc: 20, max: 100 }
                }
            });
        }
        else {
            if (options.chunkMode) {
                const stream = (_c = options.resource) !== null && _c !== void 0 ? _c : new stream_1.PassThrough({
                    // Set watermark to 64KB (default) for chunking.
                    highWaterMark: (_d = options.highWaterMark) !== null && _d !== void 0 ? _d : 64 * 1024
                });
                let downloadChunkSize = (_e = options.chunkMode.chunkSize) !== null && _e !== void 0 ? _e : 256 * 1024;
                let endBytes = downloadChunkSize + ((_f = options.startBytes) !== null && _f !== void 0 ? _f : 0), startBytes = (_g = options.startBytes) !== null && _g !== void 0 ? _g : 0;
                const pipelike = (_h = options.pipe) !== null && _h !== void 0 ? _h : true;
                let awaitDrain;
                if (pipelike) {
                    stream.on("drain", () => {
                        awaitDrain === null || awaitDrain === void 0 ? void 0 : awaitDrain();
                        awaitDrain = null;
                    });
                }
                const getNextChunk = () => {
                    if (endBytes > format.contentLength) {
                        endBytes = format.contentLength;
                    }
                    const request = miniget_1.default(format.url, {
                        headers: {
                            Range: `bytes=${startBytes}-${endBytes}`
                        }
                    });
                    // Handle unknown 403 / 410 errors accordinly.
                    request.once("error", error => {
                        try {
                            request.destroy();
                        }
                        catch { }
                        ;
                        if (error.message.includes("403")) {
                            request.removeAllListeners();
                            options.resource = stream;
                            const frmts = this.formats.filter(c => c.hasAudio && !c.hasVideo);
                            if (options._retryAmount === 5) {
                                stream.emit('error', new Error(`Max amount of tries reached.`));
                                return;
                            }
                            __1.getVideoInfo(this.url, false).then(vid => {
                                var _a, _b, _c;
                                options._retryAmount = options._retryAmount ? options._retryAmount + 1 : 1;
                                if (options.debug) {
                                    const str = `[VIDEO DEBUG]: Encountered 403 on format (URL ${this.url}), retrying download.`;
                                    if (typeof options.debug === 'function') {
                                        options.debug(str);
                                    }
                                    else
                                        console.debug(str);
                                }
                                const format = options.retryFilter ? this.formats.find(options.retryFilter) : (_c = (_b = (_a = this.formats.find(c => c.type === 'opus' && c.hasAudio && !c.hasVideo)) !== null && _a !== void 0 ? _a : this.formats.find(c => c.type === 'opus')) !== null && _b !== void 0 ? _b : this.formats.find(c => !c.hasVideo)) !== null && _c !== void 0 ? _c : this.formats[Math.floor(Math.random() * this.formats.length)];
                                if (!format) {
                                    stream.emit('error', new Error(`Could not find any format to retry.`));
                                    return;
                                }
                                vid.download(format, options);
                            });
                        }
                        else if (error.message.includes("410")) {
                            if (options.debug) {
                                const str = `[VIDEO DEBUG]: Encountered error: ${error.message} (URL ${this.url}) (410), reconnecting on bytes ${startBytes}.`;
                                if (typeof options.debug === 'function') {
                                    options.debug(str);
                                }
                                else
                                    console.debug(str);
                            }
                            options.startBytes = startBytes;
                            options.resource = stream;
                            this.download(format, options);
                        }
                        else {
                            stream.emit('error', error);
                        }
                    });
                    request.on("data", (chunk) => {
                        if (stream.destroyed) {
                            request.destroy();
                            return;
                        }
                        startBytes += chunk.length;
                        if (pipelike) {
                            if (!stream.write(chunk)) {
                                request.pause();
                                awaitDrain = () => request.resume();
                            }
                        }
                        else {
                            stream.write(chunk);
                        }
                    });
                    request.once("end", () => {
                        if (stream.destroyed)
                            return;
                        if (endBytes === format.contentLength) {
                            return;
                        }
                        endBytes = startBytes + downloadChunkSize;
                        getNextChunk();
                    });
                };
                getNextChunk();
                return stream;
            }
            else {
                const stream = new stream_1.PassThrough({ highWaterMark: format.contentLength });
                const request = miniget_1.default(format.url);
                request.once("end", request.destroy);
                stream.once("end", stream.destroy);
                request.pipe(stream);
                return stream;
            }
        }
    }
    static decipher(tokens, sig) {
        let arr = sig.split("");
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            let position;
            switch (token[0]) {
                case 'r':
                    arr = arr.reverse();
                    break;
                case 'w':
                    position = ~~token.slice(1);
                    arr = Util_1.Util.swapSignatureArray(arr, position);
                    break;
                case 's':
                    position = ~~token.slice(1);
                    arr = arr.slice(position);
                    break;
                case 'p':
                    position = ~~token.slice(1);
                    arr.splice(0, position);
                    break;
            }
        }
        return arr.join('');
    }
    get info() {
        const details = this.details;
        const formats = this.formats;
        return Object.assign(details, { formats: formats });
    }
    getHtml5Player(body) {
        var _a;
        const playerURL = (_a = body.split(`"jsUrl":"`)[1]) === null || _a === void 0 ? void 0 : _a.split('"')[0];
        this.html5Player = `${Util_1.Util.getBaseYTURL()}${playerURL}`;
        return this.html5Player;
    }
    async fetchTokens() {
        var _a, _b;
        if (cache_1.cachedTokens.has(this.html5Player) || this.tokens) {
            this.tokens = (_a = cache_1.cachedTokens.get(this.html5Player)) !== null && _a !== void 0 ? _a : this.tokens;
            return (_b = cache_1.cachedTokens.get(this.html5Player)) !== null && _b !== void 0 ? _b : this.tokens;
        }
        const request = await axios_1.default.get(this.html5Player);
        const tokens = decipher_1.extractTokens(request.data);
        cache_1.cachedTokens.set(this.html5Player, tokens);
        this.tokens = tokens;
        return tokens;
    }
    get details() {
        var _a;
        return {
            url: `${Util_1.Util.getYTVideoURL()}${(_a = this.json.videoDetails) === null || _a === void 0 ? void 0 : _a.videoId}`,
            id: this.json.videoDetails.videoId,
            title: this.json.videoDetails.title,
            duration: Number(this.json.videoDetails.lengthSeconds) * 1000,
            channelId: this.json.videoDetails.channelId,
            keywords: this.json.videoDetails.keywords,
            isOwnerViewing: this.json.videoDetails.isOwnerViewing,
            shortDescription: this.json.videoDetails.shortDescription,
            isCrawlable: this.json.videoDetails.isCrawlable,
            thumbnails: this.json.videoDetails.thumbnail.thumbnails,
            averageRating: this.json.videoDetails.averageRating,
            allowRatings: this.json.videoDetails.allowRatings,
            viewCount: Number(this.json.videoDetails.viewCount),
            isPrivate: this.json.videoDetails.isPrivate,
            author: this.json.videoDetails.author,
            isUnpluggedCorpus: this.json.videoDetails.isUnpluggedCorpus,
            isLiveContent: this.json.videoDetails.isLiveContent
        };
    }
}
exports.YoutubeVideo = YoutubeVideo;

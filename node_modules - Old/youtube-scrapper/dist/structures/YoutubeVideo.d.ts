/// <reference types="node" />
import m3u8stream from "m3u8stream";
import { PassThrough } from "stream";
export interface YoutubeVideoDetails {
    url: string;
    id: string;
    title: string;
    duration: number;
    keywords: string[];
    channelId: string;
    isOwnerViewing: boolean;
    shortDescription: string;
    isCrawlable: boolean;
    thumbnails: {
        url: string;
        height: string;
        width: string;
    }[];
    averageRating: number;
    allowRatings: boolean;
    viewCount: number;
    author: string;
    isPrivate: boolean;
    isUnpluggedCorpus: boolean;
    isLiveContent: boolean;
}
export interface YoutubeVideoFormat {
    itag: number;
    mimeType: string;
    codec: string;
    type: string;
    bitrate: number | null;
    width?: number;
    height?: number;
    initRange?: {
        start: number;
        end: number;
    };
    indexRange?: {
        start: number;
        end: number;
    };
    lastModifiedTimestamp?: number;
    contentLength?: number;
    quality?: string;
    audioChannels?: number;
    audioSampleRate?: number;
    loudnessDb?: number;
    s?: string;
    sp?: string;
    url: string;
    fps?: number;
    qualityLabel: string | null;
    projectionType?: "RECTANGULAR";
    averageBitrate?: number;
    approxDurationMs?: number;
    signatureCipher?: string;
    getDecodedCipher?: () => string | undefined;
    audioBitrate?: number | null;
    hasAudio?: boolean;
    hasVideo?: boolean;
    isLive?: boolean;
    isHLS?: boolean;
    isDashMPD?: boolean;
}
export interface DownloadOptions {
    debug?: boolean | ((info: string) => Promise<void> | void);
    retryFilter?: (format: YoutubeVideoFormat) => boolean;
    startBytes?: number;
    chunkMode?: {
        chunkSize?: number;
    };
    highWaterMark?: number;
    resource?: PassThrough;
    begin?: number | string;
    pipe?: boolean;
    /**
     * Do not use this property.
     */
    _retryAmount?: number;
}
export declare class YoutubeVideo {
    private json;
    moreFormats?: YoutubeVideoFormat[];
    html5Player?: string;
    tokens?: string[];
    constructor(json: any);
    get url(): string;
    get formats(): YoutubeVideoFormat[];
    download(format: YoutubeVideoFormat, options?: DownloadOptions): PassThrough | m3u8stream.Stream;
    static decipher(tokens: string[], sig: string): string;
    get info(): YoutubeVideoDetails & {
        formats: YoutubeVideoFormat[];
    };
    getHtml5Player(body: string): string;
    fetchTokens(): Promise<string[]>;
    get details(): YoutubeVideoDetails;
}

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Util = void 0;
const fast_xml_parser_1 = require("fast-xml-parser");
const formats_1 = __importDefault(require("./formats"));
const axios_1 = __importDefault(require("axios"));
class Util extends null {
    constructor() { }
    static getYTSearchURL() {
        return "https://www.youtube.com/results";
    }
    static getYTVideoURL() {
        return "https://www.youtube.com/watch?v=";
    }
    static getBetween(body, one, two) {
        var _a;
        return (_a = body.split(one)[1]) === null || _a === void 0 ? void 0 : _a.split(two)[0];
    }
    static getYTChannelURL() {
        return `https://youtube.com/channel`;
    }
    static getYTTrendingURL() {
        return `${Util.getBaseYTURL()}/feed/trending`;
    }
    static getYTUserURL() {
        return `https://youtube.com/user`;
    }
    static getYTPlaylistURL() {
        return "https://www.youtube.com/playlist";
    }
    static getYTApiBaseURL() {
        return `https://www.youtube.com/youtubei/v1`;
    }
    static getId(str) {
        return str.includes("/v/") ? str.split("/v/")[1].split("&")[0] : str.includes("youtube.com/embed/") ? str.split("embed/")[1].split("&")[0] : str.includes("youtu.be/") && !str.includes("/v/") ? str.split("youtu.be/")[1].split("&")[0] : str.includes("watch?v=") ? str.split("watch?v=")[1].split("&")[0] : str;
    }
    static getListId(str) {
        return str.includes("&list=") ? str.split("&list=")[1].split("&")[0] : str.includes("?list=") ? str.split("?list=")[1].split("&")[0] : str;
    }
    static getBaseYTURL() {
        return `https://youtube.com`;
    }
    static swapSignatureArray(arr, position) {
        const first = arr[0];
        arr[0] = arr[position % arr.length];
        arr[position] = first;
        return arr;
    }
    static addMetadataToFormat(format) {
        //@ts-ignore
        format = Object.assign({}, formats_1.default[format.itag], format);
        format.hasVideo = !!format.qualityLabel;
        format.hasAudio = !!format.audioBitrate;
        format.isLive = /\bsource[/=]yt_live_broadcast\b/.test(format.url);
        format.isHLS = /\/manifest\/hls_(variant|playlist)\//.test(format.url);
        format.isDashMPD = /\/manifest\/dash\//.test(format.url);
        return format;
    }
    static async dashMpdFormat(url) {
        const moreFormats = [];
        const xmlData = await axios_1.default.get(new URL(url, this.getYTVideoURL()).toString());
        const xml = fast_xml_parser_1.parse(xmlData.data, {
            attributeNamePrefix: "$",
            ignoreAttributes: false
        });
        for (const adaptationSet of xml.MPD.Period.AdaptationSet) {
            for (const representation of adaptationSet.Representation) {
                const itag = Number(representation["$id"]);
                const reservedFormat = formats_1.default[itag];
                if (reservedFormat) {
                    const format = {
                        ...reservedFormat,
                        itag, url,
                        type: reservedFormat.mimeType.split(";")[0],
                        codec: reservedFormat.mimeType.split("\"")[1].split("\"")[0]
                    };
                    if (representation["$height"]) {
                        format.width = Number(representation["$width"]);
                        format.height = Number(representation["$height"]);
                        format.fps = Number(representation["$frameRate"]);
                    }
                    moreFormats.push(this.addMetadataToFormat(format));
                }
            }
        }
        return moreFormats;
    }
    static async m3u8Format(url) {
        var _a;
        const moreFormats = [];
        const { data } = await axios_1.default.get(new URL(url, this.getYTVideoURL()).toString());
        for (const line of data.split("\n")) {
            if (!/^https?:\/\//.test(line))
                continue;
            const itag = Number((_a = line.match(/\/itag\/(\d+)\//)) === null || _a === void 0 ? void 0 : _a[1]);
            const reservedFormat = formats_1.default[itag];
            if (reservedFormat) {
                const format = {
                    ...reservedFormat,
                    itag, url: line,
                    type: reservedFormat.mimeType.split(";")[0],
                    codec: reservedFormat.mimeType.split("\"")[1].split("\"")[0]
                };
                moreFormats.push(this.addMetadataToFormat(format));
            }
        }
        return moreFormats;
    }
}
exports.Util = Util;
